{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./helpers.js","webpack:///./popup.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","injectContent","content","document","querySelector","innerHTML","getSplitElement","url","find","identifier","includes","parseURL","urlObj","info","queryString","decodeURI","split","map","tuple","printEmptyMsg","printTable","arr","reduce","acc","index","concat","getNewRoute","newTuples","pathname","urlDivider","join","urlInfo","plainUrl","qs","addEventListener","callback","chrome","tabs","query","active","currentWindow","tab","_helpers2","default","console","length","getCurrentTabUrl","evt","querySelectorAll","forEach","dataset","push","update"],"mappings":"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","file":"popup.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./popup.js\");\n","function injectContent(content) {\n  document.querySelector('#container').innerHTML = content;\n}\n\nfunction getSplitElement(url) {\n  const SPLIT_IDENTIFIERS = ['?', '#'];\n\n  // TODO\n  // - Implement custom identifier\n  return SPLIT_IDENTIFIERS.find(identifier => url.includes(identifier));\n}\n\nfunction parseURL(urlObj = {}) {\n  const QS_DIVIDER = '&';\n  const TUPLE_DIVIDER = '=';\n  const { info: { queryString } } = urlObj;\n  const arrKeyValue = queryString ? decodeURI(queryString)\n    .split(QS_DIVIDER)\n    .map((tuple) => {\n      const [key, value] = tuple.split(TUPLE_DIVIDER);\n\n      return {\n        key,\n        value,\n      };\n    }) : [];\n\n  return arrKeyValue;\n}\n\nfunction printTable(arr) {\n  const tableContent = arr.reduce((acc, value, index) => acc.concat(`\n    <tr data-index=\"${index}\">\n      <td>${value.key}</td>\n      <td>\n        <input refs=\"params\" style=\"width: 100%\" data-key=\"${value.key}\" value=\"${value.value}\" type=\"textbox\">\n      </td>\n    </tr>\n  `), '');\n\n  const TABLE = `\n    <table id=\"url-parsed-table\" class=\"pure-table pure-table-striped\">\n      <thead>\n          <tr>\n            <th>Parameter</th>\n            <th>Value</th>\n          </tr>\n      </thead>\n      <tbody>\n        ${tableContent}\n      </tbody>\n    </table>\n  `;\n\n  return TABLE;\n}\n\nfunction printEmptyMsg() {\n  return '<strong>Url without query string.</strong>';\n}\n\nfunction urlInfo(plainUrl) {\n  const SPLIT_IDENTIFIERS = ['?', '#'];\n\n  // TODO\n  // - Implement custom identifier\n  const qs = SPLIT_IDENTIFIERS.find(identifier => plainUrl.includes(identifier));\n  const [pathname, queryString] = plainUrl.split(qs);\n\n  const info = {\n    url: plainUrl,\n    pathname,\n    queryString,\n    urlDivider: qs,\n  };\n\n  return () => ({\n    info,\n  });\n}\n\nfunction getNewRoute(urlObj, newTuples) {\n  return `${urlObj.info.pathname}${urlObj.info.urlDivider}${newTuples.join('&')}`;\n}\n\nexport default {\n  injectContent,\n  getSplitElement,\n  parseURL,\n  printEmptyMsg,\n  printTable,\n  getNewRoute,\n  urlInfo,\n};\n","import './pure.css';\nimport './custom.css';\n\nimport helpers from './helpers';\n\n/**\n * Get the current URL.\n *\n * @param {function(string)} callback called when the URL of the current tab\n *   is found.\n */\nfunction getCurrentTabUrl(callback) {\n  // Query filter to be passed to chrome.tabs.query - see\n  // https://developer.chrome.com/extensions/tabs#method-query\n  const queryInfo = {\n    active: true,\n    currentWindow: true,\n  };\n\n  chrome.tabs.query(queryInfo, (tabs) => {\n    // chrome.tabs.query invokes the callback with a list of tabs that match the\n    // query. When the popup is opened, there is certainly a window and at least\n    // one tab, so we can safely assume that |tabs| is a non-empty array.\n    // A window can only have one active tab at a time, so the array consists of\n    // exactly one tab.\n    const tab = tabs[0];\n\n    // A tab is a plain object that provides information about the tab.\n    // See https://developer.chrome.com/extensions/tabs#type-Tab\n    const urlInfo = helpers.urlInfo(tab.url)();\n    const url = helpers.parseURL(urlInfo);\n    console.info(urlInfo);\n\n    const content = url.length ? helpers.printTable(url) : helpers.printEmptyMsg();\n    // tab.url is only available if the \"activeTab\" permission is declared.\n    // If you want to see the URL of other tabs (e.g. after removing active:true\n    // from |queryInfo|), then the \"tabs\" permission is required to see their\n    // \"url\" properties.\n    helpers.injectContent(content);\n\n    callback(urlInfo);\n  });\n}\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  getCurrentTabUrl((urlInfo) => {\n    const button = document.querySelector('#button');\n\n    button.addEventListener('click', (evt) => {\n      const params = document.querySelectorAll('[refs=\"params\"]');\n      const newTuples = [];\n\n      params.forEach((tuple) => {\n        const { key } = tuple.dataset;\n        const { value } = tuple;\n        newTuples.push(`${key}=${value}`);\n      });\n\n      chrome.tabs.update({\n        url: helpers.getNewRoute(urlInfo, newTuples),\n      });\n    });\n  });\n});\n"],"sourceRoot":""}